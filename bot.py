import logging
import asyncio
import gspread
from google.oauth2.service_account import Credentials
from aiogram import Bot, Dispatcher, Router, F
from aiogram.types import Message, BotCommand, BotCommandScopeChat, ReplyKeyboardMarkup, KeyboardButton, ReplyKeyboardRemove
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.filters import Command  # ‚úÖ –≠–¢–ê –°–¢–†–û–ö–ê ‚Äî –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–∞!
from datetime import datetime
import os
import json
from collections import defaultdict, deque
from aiogram.dispatcher.middlewares.base import BaseMiddleware


from logging.handlers import RotatingFileHandler

# üîß –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è —Å —Ä–æ—Ç–∞—Ü–∏–µ–π
log_handler = RotatingFileHandler(
    filename="bot.log",       # –æ—Å–Ω–æ–≤–Ω–æ–π —Ñ–∞–π–ª –ª–æ–≥–æ–≤
    maxBytes=1_000_000,       # –º–∞–∫—Å–∏–º—É–º 1 –ú–ë –Ω–∞ —Ñ–∞–π–ª
    backupCount=5             # —Ö—Ä–∞–Ω–∏—Ç—å –¥–æ 5 —Ñ–∞–π–ª–æ–≤: bot.log.1, ..., bot.log.5
)

log_formatter = logging.Formatter("%(asctime)s - %(levelname)s - %(message)s")
log_handler.setFormatter(log_formatter)

logging.basicConfig(
    level=logging.INFO,
    handlers=[log_handler]
)


# ==========================
# üîπ –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –±–æ—Ç–∞ –∏ —Ç–∞–±–ª–∏—Ü—ã
# ==========================

TOKEN = "6974697621:AAHM4qa91k4nq4Hsbn-rSDTkL8-6hAsa3pA"  # –£–∫–∞–∂–∏ —Å–≤–æ–π —Ç–æ–∫–µ–Ω –ø—Ä—è–º–æ –≤ –∫–æ–¥–µ –∏–ª–∏ –∑–∞–≥—Ä—É–∑–∏ –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –æ–∫—Ä—É–∂–µ–Ω–∏—è
SHEET_ID = "1QaR920L5bZUGNLk02M-lgXr9c5_nHJQVoPgPL7UVVY4"
ADMIN_IDS = ["665932047", "473541446"]  # Telegram ID –∞–¥–º–∏–Ω–∞

# –ó–∞–≥—Ä—É–∑–∫–∞ JSON-–∫–ª—é—á–µ–π –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –æ–∫—Ä—É–∂–µ–Ω–∏—è
with open("/root/Tlcbot/credentials/tlcbot-453608-3ac701333130.json") as f:
    google_creds_json = json.load(f)


# –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –≤ Google Sheets —á–µ—Ä–µ–∑ JSON-–∫–ª—é—á–∏
scope = ["https://www.googleapis.com/auth/spreadsheets", "https://www.googleapis.com/auth/drive"]
credentials = Credentials.from_service_account_info(google_creds_json, scopes=scope)
gc = gspread.authorize(credentials)

# –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ Google Sheets
spreadsheet = gc.open_by_key(SHEET_ID)

# –ü–æ–ª—É—á–∞–µ–º –ª–∏—Å—Ç—ã
users_sheet = spreadsheet.worksheet("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏")
tracking_sheet = spreadsheet.worksheet("–¢—Ä–µ–∫–∏–Ω–≥")
china_sheet = spreadsheet.worksheet("–ö–∏—Ç–∞–π")
kz_sheet = spreadsheet.worksheet("–ö–∞–∑–∞—Ö—Å—Ç–∞–Ω")
issued_sheet = spreadsheet.worksheet("–í—ã–¥–∞–Ω–Ω–æ–µ")  # –õ–∏—Å—Ç –¥–ª—è –≤—ã–¥–∞–Ω–Ω—ã—Ö –ø–æ—Å—ã–ª–æ–∫
texts_sheet = spreadsheet.worksheet("–¢–µ–∫—Å—Ç—ã")  # –ü–æ–¥–∫–ª—é—á–∞–µ–º –ª–∏—Å—Ç —Å —Ç–µ–∫—Å—Ç–∞–º–∏

TEXTS = {}  # –ì–ª–æ–±–∞–ª—å–Ω—ã–π —Å–ª–æ–≤–∞—Ä—å –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Ç–µ–∫—Å—Ç–æ–≤

def load_texts():
    global TEXTS
    records = texts_sheet.get_all_values()
    TEXTS = {row[0]: row[1] for row in records if len(row) > 1}  # –ó–∞–≥—Ä—É–∂–∞–µ–º –≤—Å–µ —Ç–µ–∫—Å—Ç—ã –≤ –ø–∞–º—è—Ç—å

def get_text(key, **kwargs):
    text = TEXTS.get(key, f"‚ö†Ô∏è –¢–µ–∫—Å—Ç '{key}' –Ω–µ –Ω–∞–π–¥–µ–Ω!")  # –ë–µ—Ä–µ–º —Ç–µ–∫—Å—Ç –∏–∑ –ø–∞–º—è—Ç–∏
    return text.format(**kwargs)  # –ü–æ–¥—Å—Ç–∞–≤–ª—è–µ–º –∑–Ω–∞—á–µ–Ω–∏—è, –µ—Å–ª–∏ –µ—Å—Ç—å



# ==========================
# üîπ FSM –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏
# ==========================
class Registration(StatesGroup):
    name = State()
    city = State()
    phone = State()
    manager_code = State()

# üîπ FSM –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ç—Ä–µ–∫–∞–º–∏ (–î–æ–±–∞–≤–ª—è–µ–º —Å—é–¥–∞!)
class TrackManagement(StatesGroup):
    selecting_track = State()
    adding_signature = State()
    deleting_track = State()



# ==========================
# üîπ –°–æ–∑–¥–∞–Ω–∏–µ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
# ==========================
user_keyboard = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="üì¶ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç–∞—Ç—É—Å –ø–æ—Å—ã–ª–æ–∫"), KeyboardButton(text="üñä –ü–æ–¥–ø–∏—Å–∞—Ç—å —Ç—Ä–µ–∫-–Ω–æ–º–µ—Ä")],
        [KeyboardButton(text="‚ùå –£–¥–∞–ª–∏—Ç—å —Ç—Ä–µ–∫-–Ω–æ–º–µ—Ä"), KeyboardButton(text="üìû –°–≤—è–∑–∞—Ç—å—Å—è —Å –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º")],
    ],
    resize_keyboard=True,
    one_time_keyboard=False  # –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –æ—Å—Ç–∞—ë—Ç—Å—è –Ω–∞ —ç–∫—Ä–∞–Ω–µ
)

class QueueMiddleware(BaseMiddleware):
    def __init__(self, max_queue: int = 10):
        self.user_locks: dict[int, asyncio.Lock] = {}
        self.waiting_count: dict[int, int] = {}
        self.max_queue = max_queue

    async def __call__(self, handler, event, data):
        user_id = event.from_user.id if event.from_user else None
        if user_id is None:
            return await handler(event, data)

        if user_id not in self.user_locks:
            self.user_locks[user_id] = asyncio.Lock()
            self.waiting_count[user_id] = 0

        lock = self.user_locks[user_id]

        if lock.locked():
            if self.waiting_count[user_id] >= self.max_queue:
                return  # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
            self.waiting_count[user_id] += 1
            async with lock:
                self.waiting_count[user_id] -= 1
                return await handler(event, data)
        else:
            async with lock:
                return await handler(event, data)

        
# –°–æ–∑–¥–∞–Ω–∏–µ –±–æ—Ç–∞ –∏ –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∞
bot = Bot(token=TOKEN)
dp = Dispatcher(storage=MemoryStorage())
router = Router()
dp.include_router(router)
dp.message.middleware(QueueMiddleware())  # <-- —ç—Ç–∞ —Å—Ç—Ä–æ–∫–∞ –æ—Å—Ç–∞—ë—Ç—Å—è –∑–¥–µ—Å—å


# ==========================
# üîπ –ö–æ–º–∞–Ω–¥—ã –±–æ—Ç–∞
USER_COMMANDS = [
    BotCommand(command="register", description="üìù –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è"),
    BotCommand(command="check_status", description="üì¶ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç–∞—Ç—É—Å –ø–æ—Å—ã–ª–æ–∫"),
    BotCommand(command="sign_track", description="üñä –ü–æ–¥–ø–∏—Å–∞—Ç—å —Ç—Ä–µ–∫-–Ω–æ–º–µ—Ä"),
    BotCommand(command="delete_track", description="‚ùå –£–¥–∞–ª–∏—Ç—å —Ç—Ä–µ–∫-–Ω–æ–º–µ—Ä"),
    BotCommand(command="contact_manager", description="üìû –°–≤—è–∑–∞—Ç—å—Å—è —Å –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º"),
    BotCommand(command="cancel", description="‚ùå –û—Ç–º–µ–Ω–∏—Ç—å —Ç–µ–∫—É—â–µ–µ –¥–µ–π—Å—Ç–≤–∏–µ"),
]

ADMIN_COMMANDS = USER_COMMANDS + [
    BotCommand(command="check_china", description="üá®üá≥ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ö–∏—Ç–∞–π"),
    BotCommand(command="check_kz", description="üá∞üáø –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ö–∞–∑–∞—Ö—Å—Ç–∞–Ω"),
    BotCommand(command="check_issued", description="üì¶ –û–±–Ω–æ–≤–∏—Ç—å '–í—ã–¥–∞–Ω–Ω–æ–µ'"),
    BotCommand(command="push", description="üì¢ –ú–∞—Å—Å–æ–≤–∞—è —Ä–∞—Å—Å—ã–ª–∫–∞"),
    BotCommand(command="update_texts", description="üîÑ –û–±–Ω–æ–≤–∏—Ç—å —Ç–µ–∫—Å—Ç—ã —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π"),
]

async def set_bot_commands():

    await bot.set_my_commands(USER_COMMANDS)

    for admin_id in ADMIN_IDS:

        await bot.set_my_commands(ADMIN_COMMANDS, scope=BotCommandScopeChat(chat_id=admin_id))

# ==========================
# üîπ –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–æ–º–∞–Ω–¥
# ==========================

# ‚úÖ /start
@router.message(F.text == "/start")
async def start_handler(message: Message):
    logging.info(f"/start –æ—Ç {message.from_user.id}")
    await message.answer(get_text("start_message"))

# –•—Ä–∞–Ω–∏–º ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, —É –∫–æ—Ç–æ—Ä—ã—Ö –∏–¥—ë—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∞ —à–∞–≥–∞
processing_users = set()

@router.message(Command("register"))
async def register_command(message: Message, state: FSMContext):
    user_id = str(message.from_user.id)

    # –ü—Ä–æ–≤–µ—Ä–∫–∞: —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω?
    existing = users_sheet.col_values(1)
    if user_id in existing:
        await message.answer(get_text("already_registered"))
        return

    # –ó–∞—â–∏—Ç–∞ –æ—Ç –¥–≤–æ–π–Ω—ã—Ö –∫–ª–∏–∫–æ–≤ –∏ –ª–∞–≥–æ–≤
    if user_id in processing_users:
        await message.answer("‚è≥ –ü–æ–¥–æ–∂–¥–∏—Ç–µ, –∏–¥—ë—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∞ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ —à–∞–≥–∞...")
        return

    processing_users.add(user_id)
    try:
        await state.clear()
        await state.update_data(user_id=user_id)
        await state.set_state(Registration.name)
        await asyncio.sleep(0.1)
        await message.answer(get_text("ask_name"))
    finally:
        processing_users.discard(user_id)

@router.message(Registration.name)
async def register_name_handler(message: Message, state: FSMContext):
    if message.text.lower() in ["–æ—Ç–º–µ–Ω–∞", "/–æ—Ç–º–µ–Ω–∞", "/cancel"]:
        await cancel_handler(message, state)
        return

    await state.update_data(name=message.text.strip())
    await state.set_state(Registration.city)
    await message.answer(get_text("ask_city"))

@router.message(Registration.city)
async def register_city_handler(message: Message, state: FSMContext):
    if message.text.lower() in ["–æ—Ç–º–µ–Ω–∞", "/–æ—Ç–º–µ–Ω–∞", "/cancel"]:
        await cancel_handler(message, state)
        return

    await state.update_data(city=message.text.strip())
    await state.set_state(Registration.phone)
    await message.answer(get_text("ask_phone"))

@router.message(Registration.phone)
async def register_phone_handler(message: Message, state: FSMContext):
    if message.text.lower() in ["–æ—Ç–º–µ–Ω–∞", "/–æ—Ç–º–µ–Ω–∞", "/cancel"]:
        await cancel_handler(message, state)
        return

    await state.update_data(phone=message.text.strip())
    await state.set_state(Registration.manager_code)
    await message.answer(get_text("ask_manager_code"))

@router.message(Registration.manager_code)
async def register_manager_handler(message: Message, state: FSMContext):
    if message.text.lower() in ["–æ—Ç–º–µ–Ω–∞", "/–æ—Ç–º–µ–Ω–∞", "/cancel"]:
        await cancel_handler(message, state)
        return

    data = await state.get_data()
    user_id = data["user_id"]
    name = data["name"]
    city = data["city"]
    phone = data["phone"]
    manager_code = message.text.strip()

    logging.info(f"‚úÖ –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º: {user_id}, {name}, {city}, {phone}, –∫–æ–¥: {manager_code}")

    users_sheet.append_row([user_id, name, city, phone, manager_code])
    await message.answer(get_text("registration_complete"), reply_markup=user_keyboard)
    await state.clear()


# ‚úÖ /check_status ‚Äì –ø—Ä–æ–≤–µ—Ä–∫–∞ —Ç—Ä–µ–∫–æ–≤ (–û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)
@router.message(F.text.in_(["üì¶ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç–∞—Ç—É—Å –ø–æ—Å—ã–ª–æ–∫", "/check_status"]))
async def check_status_handler(message: Message):
    user_id = str(message.from_user.id)
    
    # –ó–∞–≥—Ä—É–∂–∞–µ–º –≤—Å–µ –¥–∞–Ω–Ω—ã–µ
    tracking_records = tracking_sheet.get_all_values()
    china_records = {row[0].strip().lower(): row[2] for row in china_sheet.get_all_values()[1:] if len(row) > 2}  # –ö–∏—Ç–∞–π (—Ç—Ä–µ–∫ -> –¥–∞—Ç–∞)
    kz_records = {row[0].strip().lower(): row[2] for row in kz_sheet.get_all_values()[1:] if len(row) > 2}  # –ö–∞–∑–∞—Ö—Å—Ç–∞–Ω (—Ç—Ä–µ–∫ -> –¥–∞—Ç–∞)
    issued_records = {row[0].strip().lower(): row[2] for row in issued_sheet.get_all_values()[1:] if len(row) > 2}  # –í—ã–¥–∞–Ω–Ω–æ–µ (—Ç—Ä–µ–∫ -> –¥–∞—Ç–∞)

    user_tracks = []
    
    # –ù–∞—Ö–æ–¥–∏–º –≤—Å–µ —Ç—Ä–µ–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    for row in tracking_records[1:]:
        if len(row) > 4 and row[4] == user_id:  # –ü—Ä–æ–≤–µ—Ä—è–µ–º ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ 5-–π –∫–æ–ª–æ–Ω–∫–µ
            track_number = row[0].strip().lower()  # –¢—Ä–µ–∫-–Ω–æ–º–µ—Ä
            signature = row[3] if len(row) > 3 and row[3] else "–ë–µ–∑ –ø–æ–¥–ø–∏—Å–∏"  # –ü–æ–¥–ø–∏—Å—å

            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å—Ç–∞—Ç—É—Å, –¥–∞—Ç—É –∏ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä
            if track_number in issued_records:
                indicator, status = "‚úÖ", "–í—ã–¥–∞–Ω–∞"
                date = issued_records[track_number]
            elif track_number in kz_records:
                indicator, status = "üü¢", "–ü—Ä–∏–±—ã–ª–∞ –≤ –ö–∞–∑–∞—Ö—Å—Ç–∞–Ω"
                date = kz_records[track_number]
            elif track_number in china_records:
                indicator, status = "üîµ", "–í –ø—É—Ç–∏ –¥–æ –ê–ª–º–∞—Ç—ã"
                date = china_records[track_number]
            else:
                indicator, status = "üü†", "–û–∂–∏–¥–∞–µ—Ç—Å—è –Ω–∞ —Å–∫–ª–∞–¥–µ –≤ –ö–∏—Ç–∞–µ"
                date = ""

            # –î–æ–±–∞–≤–ª—è–µ–º —Ç—Ä–µ–∫ –≤ —Å–ø–∏—Å–æ–∫
            user_tracks.append((indicator, status, track_number.upper(), date, signature))

    # –°–æ—Ä—Ç–∏—Ä—É–µ–º —Å–ø–∏—Å–æ–∫: üü† –¢—Ä–µ–∫–∏–Ω–≥ ‚Üí üîµ –ö–∏—Ç–∞–π ‚Üí üü¢ –ö–∞–∑–∞—Ö—Å—Ç–∞–Ω ‚Üí ‚úÖ –í—ã–¥–∞–Ω–Ω–æ–µ
    user_tracks.sort(key=lambda x: ["üü†", "üîµ", "üü¢", "‚úÖ"].index(x[0]))

    # –§–æ—Ä–º–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç –æ—Ç–≤–µ—Ç–∞
    if not user_tracks:
        await message.answer("üì≠ –£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Ç—Ä–µ–∫-–Ω–æ–º–µ—Ä–æ–≤.")
        return

    text = get_text("status_header") + "\n"
    for indicator, status, track_number, date, signature in user_tracks:
        date_part = f" ({date})" if date else ""
        text += f"{indicator} {status}: {track_number}{date_part} ({signature})\n"

    await message.answer(text)


# –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏—è FSM (–î–æ–±–∞–≤—å –≤ –Ω–∞—á–∞–ª–æ —Ñ–∞–π–ª–∞)
class TrackSigning(StatesGroup):
    selecting_track = State()
    entering_signature = State()



# –•—Ä–∞–Ω–∏–ª–∏—â–µ –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ FSM
active_states = {}

# ‚úÖ –ü–æ–¥–ø–∏—Å–∞—Ç—å —Ç—Ä–µ–∫-–Ω–æ–º–µ—Ä
@router.message(F.text.in_(["üñä –ü–æ–¥–ø–∏—Å–∞—Ç—å —Ç—Ä–µ–∫-–Ω–æ–º–µ—Ä", "/sign_track"]))
async def sign_track_handler(message: Message, state: FSMContext):
    user_id = str(message.from_user.id)

    # –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º –ø–æ–≤—Ç–æ—Ä–Ω—ã–π –∑–∞–ø—É—Å–∫ FSM
    current_state = await state.get_state()
    if current_state is not None:
        await message.answer("‚è≥ –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–≤–µ—Ä—à–∏—Ç–µ –ø—Ä–µ–¥—ã–¥—É—â–µ–µ –¥–µ–π—Å—Ç–≤–∏–µ –∏–ª–∏ –≤–≤–µ–¥–∏—Ç–µ /–æ—Ç–º–µ–Ω–∞.")
        return

    await state.clear()

    # –ü–æ–ª—É—á–∞–µ–º —Ç—Ä–µ–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    user_tracks = [
        row[0].strip().upper()
        for row in tracking_sheet.get_all_values()
        if len(row) > 4 and row[4] == user_id
    ]

    if not user_tracks:
        await message.answer("üì≠ –£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Ç—Ä–µ–∫-–Ω–æ–º–µ—Ä–æ–≤.")
        return

    # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å —Ç—Ä–µ–∫–∞–º–∏
    keyboard = ReplyKeyboardMarkup(
        keyboard=[[KeyboardButton(text=track)] for track in user_tracks],
        resize_keyboard=True,
        one_time_keyboard=True
    )

    await state.set_state(TrackSigning.selecting_track)
    await asyncio.sleep(0.1)
    await message.answer("‚úèÔ∏è –í—ã–±–µ—Ä–∏—Ç–µ —Ç—Ä–µ–∫-–Ω–æ–º–µ—Ä, –∫–æ—Ç–æ—Ä—ã–π —Ö–æ—Ç–∏—Ç–µ –ø–æ–¥–ø–∏—Å–∞—Ç—å:", reply_markup=keyboard)


# –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã–±–æ—Ä–∞ —Ç—Ä–µ–∫–∞
@router.message(TrackSigning.selecting_track)
async def process_track_selection(message: Message, state: FSMContext):
    if message.text.lower() in ["–æ—Ç–º–µ–Ω–∞", "/–æ—Ç–º–µ–Ω–∞", "/cancel"]:
        await cancel_handler(message, state)
        return
    
    selected_track = message.text.strip().upper()
    user_id = str(message.from_user.id)

    # –ü—Ä–æ–≤–µ—Ä–∫–∞, –µ—Å—Ç—å –ª–∏ —Ç—Ä–µ–∫ —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    user_tracks = [
        row[0].strip().upper()
        for row in tracking_sheet.get_all_values()
        if len(row) > 4 and row[4] == user_id
    ]

    if selected_track not in user_tracks:
        await message.answer("‚ùå –¢–∞–∫–æ–π —Ç—Ä–µ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –æ–¥–∏–Ω –∏–∑ —Å–ø–∏—Å–∫–∞.")
        return

    await state.update_data(selected_track=selected_track)
    await state.set_state(TrackSigning.entering_signature)
    await asyncio.sleep(0.1)
    await message.answer("‚úèÔ∏è –í–≤–µ–¥–∏—Ç–µ –ø–æ–¥–ø–∏—Å—å –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —Ç—Ä–µ–∫-–Ω–æ–º–µ—Ä–∞:", reply_markup=ReplyKeyboardRemove())

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–¥–ø–∏—Å–∏
@router.message(TrackSigning.entering_signature)
async def process_signature(message: Message, state: FSMContext):
    if message.text.lower() in ["–æ—Ç–º–µ–Ω–∞", "/–æ—Ç–º–µ–Ω–∞", "/cancel"]:
        await cancel_handler(message, state)
        return
    
    user_id = str(message.from_user.id)
    data = await state.get_data()
    selected_track = data.get("selected_track")
    signature = message.text.strip()

    if not selected_track:
        await message.answer("‚ö†Ô∏è –ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫. –í–≤–µ–¥–∏—Ç–µ /–æ—Ç–º–µ–Ω–∞ –∏ –Ω–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ.")
        await state.clear()
        return

    # –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–¥–ø–∏—Å—å –≤ —Ç–∞–±–ª–∏—Ü–µ
    records = tracking_sheet.get_all_values()
    for i, row in enumerate(records):
        if row[0].strip().upper() == selected_track and len(row) > 4 and row[4] == user_id:
            tracking_sheet.update_cell(i + 1, 4, signature)  # –°—Ç–æ–ª–±–µ—Ü D ‚Äî –ø–æ–¥–ø–∏—Å—å
            await message.answer(f"‚úÖ –ü–æ–¥–ø–∏—Å—å –æ–±–Ω–æ–≤–ª–µ–Ω–∞ –¥–ª—è {selected_track}: {signature}")
            await state.clear()
            return

    await message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ —Ç—Ä–µ–∫-–Ω–æ–º–µ—Ä. –í–≤–µ–¥–∏—Ç–µ /–æ—Ç–º–µ–Ω–∞ –∏ –Ω–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ.")
    await state.clear()

    
class TrackDeleting(StatesGroup):
    selecting_track = State()

# ‚úÖ –£–¥–∞–ª–∏—Ç—å —Ç—Ä–µ–∫-–Ω–æ–º–µ—Ä
@router.message(F.text.in_(["‚ùå –£–¥–∞–ª–∏—Ç—å —Ç—Ä–µ–∫-–Ω–æ–º–µ—Ä", "/delete_track"]))
async def delete_track_handler(message: Message, state: FSMContext):
    user_id = str(message.from_user.id)

    current_state = await state.get_state()
    if current_state is not None:
        await message.answer("‚è≥ –ó–∞–≤–µ—Ä—à–∏—Ç–µ –ø—Ä–µ–¥—ã–¥—É—â–µ–µ –¥–µ–π—Å—Ç–≤–∏–µ –∏–ª–∏ –≤–≤–µ–¥–∏—Ç–µ /–æ—Ç–º–µ–Ω–∞.")
        return

    await state.clear()

    # –ü–æ–ª—É—á–∞–µ–º —Ç—Ä–µ–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    user_tracks = [
        row[0].strip().upper()
        for row in tracking_sheet.get_all_values()
        if len(row) > 4 and row[4] == user_id
    ]

    if not user_tracks:
        await message.answer("üì≠ –£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Ç—Ä–µ–∫-–Ω–æ–º–µ—Ä–æ–≤.")
        return

    keyboard = ReplyKeyboardMarkup(
        keyboard=[[KeyboardButton(text=track)] for track in user_tracks],
        resize_keyboard=True,
        one_time_keyboard=True
    )

    await state.set_state(TrackDeleting.selecting_track)
    await asyncio.sleep(0.1)
    await message.answer("‚ùå –í—ã–±–µ—Ä–∏—Ç–µ —Ç—Ä–µ–∫-–Ω–æ–º–µ—Ä, –∫–æ—Ç–æ—Ä—ã–π —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å:", reply_markup=keyboard)



@router.message(TrackDeleting.selecting_track)
async def confirm_deletion(message: Message, state: FSMContext):
    if message.text.lower() in ["–æ—Ç–º–µ–Ω–∞", "/–æ—Ç–º–µ–Ω–∞", "/cancel"]:
        await cancel_handler(message, state)
        return
    
    user_id = str(message.from_user.id)
    track_to_delete = message.text.strip().upper()

    records = tracking_sheet.get_all_values()

    for i, row in enumerate(records):
        if row[0].strip().upper() == track_to_delete and len(row) > 4 and row[4] == user_id:
            tracking_sheet.delete_rows(i + 1)
            await message.answer(f"‚úÖ –¢—Ä–µ–∫-–Ω–æ–º–µ—Ä {track_to_delete} —É–¥–∞–ª—ë–Ω.", reply_markup=user_keyboard)
            await state.clear()
            return

    await message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ —Ç—Ä–µ–∫-–Ω–æ–º–µ—Ä. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –∏–∑ —Å–ø–∏—Å–∫–∞ –∏–ª–∏ –≤–≤–µ–¥–∏—Ç–µ /–æ—Ç–º–µ–Ω–∞.")


# ‚úÖ /contact_manager ‚Äì —Å–≤—è–∑—å —Å –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º
@router.message(F.text.in_(["üìû –°–≤—è–∑–∞—Ç—å—Å—è —Å –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º", "/contact_manager"]))
async def contact_manager_handler(message: Message):
    logging.info(f"üîò –ö–Ω–æ–ø–∫–∞ '–°–≤—è–∑–∞—Ç—å—Å—è —Å –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º' –Ω–∞–∂–∞—Ç–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º {message.from_user.id}")

    whatsapp_link = "https://wa.me/77028888252"
    text = f"üìû –°–≤—è–∂–∏—Ç–µ—Å—å —Å –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º —á–µ—Ä–µ–∑ [WhatsApp]({whatsapp_link})"

    await message.answer(text, parse_mode="Markdown", disable_web_page_preview=True)



# ‚úÖ /push ‚Äì –º–∞—Å—Å–æ–≤–∞—è —Ä–∞—Å—Å—ã–ª–∫–∞ (—Ç–æ–ª—å–∫–æ –¥–ª—è –∞–¥–º–∏–Ω–∞)
from aiogram.fsm.state import StatesGroup, State

class PushNotification(StatesGroup):
    awaiting_message = State()

@router.message(F.text == "/push")
async def start_push_handler(message: Message, state: FSMContext):
    if str(message.from_user.id) not in ADMIN_IDS:
        await message.answer("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã!")
        return

    await state.set_state(PushNotification.awaiting_message)
    await message.answer("‚úâÔ∏è –í–≤–µ–¥–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏:")

@router.message(PushNotification.awaiting_message)
async def send_push_handler(message: Message, state: FSMContext):
    push_text = message.text.strip()

    # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∏–∑ —Ç–∞–±–ª–∏—Ü—ã
    user_ids = users_sheet.col_values(1)  # –ü–µ—Ä–≤—ã–π —Å—Ç–æ–ª–±–µ—Ü ‚Äî user_id
    sent_count = 0

    for user_id in user_ids[1:]:  # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫ —Ç–∞–±–ª–∏—Ü—ã
        try:
            await bot.send_message(user_id, push_text)
            sent_count += 1
        except Exception as e:
            logging.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {user_id}: {e}")

    await message.answer(f"‚úÖ –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ {sent_count} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º.")
    await state.clear()  # –û—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ FSM

    # üõ°Ô∏è –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ (–µ—Å–ª–∏ –µ—â—ë –Ω–µ –¥–æ–±–∞–≤–ª–µ–Ω—ã)
is_notifying = is_notifying if 'is_notifying' in globals() else {"china": False, "kz": False}
pending_notifications = pending_notifications if 'pending_notifications' in globals() else {"china": [], "kz": []}


# ‚úÖ –û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –ø–æ –ö–ê–ó–ê–•–°–¢–ê–ù–£
async def send_kz_notifications():
    filename = "pending_kz.json"
    if not os.path.exists(filename): return
    with open(filename, "r") as f: notifications = json.load(f)
    count = 0
    for item in notifications:
        text = get_text("kz_notification", track=item["track"]) + (f" ({item['date']})" if item.get("date") else "")
        try:
            await bot.send_message(item["user_id"], text)
            await asyncio.sleep(0.6)
        except Exception as e:
            logging.warning(f"KZ ‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ {item['user_id']}: {e}")
            continue
        try:
            kz_sheet.update(f"D{item['row_index']}", [[item['manager_code']]])
            await asyncio.sleep(0.2)
            kz_sheet.update(f"E{item['row_index']}", [[item['signature']]])
            await asyncio.sleep(0.2)
            kz_sheet.update(f"F{item['row_index']}", [[item['user_id']]])
            await asyncio.sleep(0.2)
            kz_sheet.update(f"B{item['row_index']}", [["‚úÖ"]])
            await asyncio.sleep(0.2)
        except Exception as e:
            logging.warning(f"KZ ‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Ç–∞–±–ª–∏—Ü—ã: {e}")
        count += 1
    os.remove(filename)
    for admin_id in ADMIN_IDS:
        await bot.send_message(admin_id, f"‚úÖ KZ: –û–ø–æ–≤–µ—â–µ–Ω–æ {count} —á–µ–ª–æ–≤–µ–∫.")

@router.message(Command("check_kz"))
async def check_kz_handler(message: Message):
    if str(message.from_user.id) not in ADMIN_IDS:
        await message.answer("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã!")
        return
    if os.path.exists("pending_kz.json"):
        await message.answer("‚ö†Ô∏è –ü—Ä–µ–¥—ã–¥—É—â–∞—è —Ä–∞—Å—Å—ã–ª–∫–∞ –µ—â—ë –Ω–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!")
        return
    records = kz_sheet.get_all_values()
    tracking = tracking_sheet.get_all_values()
    issued_data = issued_sheet.get_all_values()
    notif, updates, cache = [], [], set()
    for i in range(len(records) - 1, 0, -1):
        row = records[i]; track = row[0].strip().lower()
        if not track or (len(row) > 1 and row[1] in ["‚úÖ", "üü®"]): continue

        in_issued = any(track == r[0].strip().lower() for r in issued_data[1:])
        if in_issued:
            user_id = manager_code = signature = None
            for t in tracking[1:]:
                if track == t[0].strip().lower():
                    user_id, manager_code, signature = t[4], t[2], t[3]; break
            try:
                kz_sheet.update(f"D{i+1}", [[manager_code]])
                await asyncio.sleep(0.2)
                kz_sheet.update(f"E{i+1}", [[signature]])
                await asyncio.sleep(0.2)
                kz_sheet.update(f"F{i+1}", [[user_id]])
                await asyncio.sleep(0.2)
                kz_sheet.update(f"B{i+1}", [["‚úÖ"]])
                await asyncio.sleep(0.2)
            except Exception as e:
                logging.warning(f"KZ ‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –∞–≤—Ç–æ–∑–∞–∫—Ä—ã—Ç–∏–∏ —Ç—Ä–µ–∫–∞ {track.upper()}: {e}")
            continue

        user_id = manager_code = signature = None
        date = row[2] if len(row) > 2 else ""
        for t in tracking[1:]:
            if track == t[0].strip().lower():
                user_id, manager_code, signature = t[4], t[2], t[3]; break
        if user_id:
            key = f"{user_id}:{track}"
            if key in cache: continue
            cache.add(key)
            notif.append({"row_index": i+1, "track": track.upper(), "user_id": user_id,
                          "manager_code": manager_code, "signature": signature, "date": date})
            updates.append({"range": f"B{i+1}", "values": [["‚úÖ"]]})
    if not notif:
        await message.answer("üì≠ –ù–æ–≤—ã—Ö —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –ø–æ –ö–∞–∑–∞—Ö—Å—Ç–∞–Ω—É –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")
        return
    try:
        kz_sheet.batch_update(updates)
    except Exception as e:
        logging.warning(f"KZ –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ç–∞–±–ª–∏—Ü—ã: {e}")
        await message.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Ç–∞–±–ª–∏—Ü—ã!")
        return
    with open("pending_kz.json", "w") as f: json.dump(notif, f)
    await message.answer(f"‚úÖ –ö–∞–∑–∞—Ö—Å—Ç–∞–Ω: –Ω–∞–π–¥–µ–Ω–æ {len(notif)} —á–µ–ª–æ–≤–µ–∫. –†–∞—Å—Å—ã–ª–∫–∞ –Ω–∞—á–∞–ª–∞—Å—å...")
    asyncio.create_task(send_kz_notifications())

# ‚úÖ –û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –ø–æ –ö–ò–¢–ê–Æ
async def send_china_notifications():
    filename = "pending_china.json"
    if not os.path.exists(filename): return
    with open(filename, "r") as f: notifications = json.load(f)
    count = 0
    for item in notifications:
        text = get_text("china_notification", track=item["track"]) + (f" ({item['date']})" if item.get("date") else "")
        try:
            await bot.send_message(item["user_id"], text)
            await asyncio.sleep(0.6)
        except Exception as e:
            logging.warning(f"CN ‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ {item['user_id']}: {e}")
            continue
        try:
            china_sheet.update(f"D{item['row_index']}", [[item['manager_code']]])
            await asyncio.sleep(0.2)
            china_sheet.update(f"E{item['row_index']}", [[item['signature']]])
            await asyncio.sleep(0.2)
            china_sheet.update(f"F{item['row_index']}", [[item['user_id']]])
            await asyncio.sleep(0.2)
            china_sheet.update(f"B{item['row_index']}", [["‚úÖ"]])
            await asyncio.sleep(0.2)
        except Exception as e:
            logging.warning(f"CN ‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Ç–∞–±–ª–∏—Ü—ã: {e}")
        count += 1
    os.remove(filename)
    for admin_id in ADMIN_IDS:
        await bot.send_message(admin_id, f"‚úÖ CN: –û–ø–æ–≤–µ—â–µ–Ω–æ {count} —á–µ–ª–æ–≤–µ–∫.")

@router.message(Command("check_china"))
async def check_china_handler(message: Message):
    if str(message.from_user.id) not in ADMIN_IDS:
        await message.answer("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã!")
        return
    if os.path.exists("pending_china.json"):
        await message.answer("‚ö†Ô∏è –ü—Ä–µ–¥—ã–¥—É—â–∞—è —Ä–∞—Å—Å—ã–ª–∫–∞ –µ—â—ë –Ω–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!")
        return
    records = china_sheet.get_all_values()
    tracking = tracking_sheet.get_all_values()
    kz_data = kz_sheet.get_all_values()
    issued_data = issued_sheet.get_all_values()

    notif, updates, cache = [], [], set()
    for i in range(len(records) - 1, 0, -1):
        row = records[i]
        track = row[0].strip().lower()
        if not track or (len(row) > 1 and row[1] in ["‚úÖ", "üü®"]): continue

        in_next_stage = any(track == r[0].strip().lower() for r in kz_data[1:] + issued_data[1:])
        if in_next_stage:
            user_id = manager_code = signature = None
            for t in tracking[1:]:
                if track == t[0].strip().lower():
                    user_id, manager_code, signature = t[4], t[2], t[3]
                    break
            try:
                china_sheet.update(f"D{i+1}", [[manager_code]])
                await asyncio.sleep(0.2)
                china_sheet.update(f"E{i+1}", [[signature]])
                await asyncio.sleep(0.2)
                china_sheet.update(f"F{i+1}", [[user_id]])
                await asyncio.sleep(0.2)
                china_sheet.update(f"B{i+1}", [["‚úÖ"]])
                await asyncio.sleep(0.2)
            except Exception as e:
                logging.warning(f"CN ‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –∞–≤—Ç–æ–∑–∞–∫—Ä—ã—Ç–∏–∏ —Ç—Ä–µ–∫–∞ {track.upper()}: {e}")
            continue

        user_id = manager_code = signature = None
        date = row[2] if len(row) > 2 else ""
        for t in tracking[1:]:
            if track == t[0].strip().lower():
                user_id, manager_code, signature = t[4], t[2], t[3]
                break
        if user_id:
            key = f"{user_id}:{track}"
            if key in cache: continue
            cache.add(key)
            notif.append({"row_index": i+1, "track": track.upper(), "user_id": user_id,
                          "manager_code": manager_code, "signature": signature, "date": date})
            updates.append({"range": f"B{i+1}", "values": [["‚úÖ"]]})

    if not notif:
        await message.answer("üì≠ –ù–æ–≤—ã—Ö —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –ø–æ –ö–∏—Ç–∞—é –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")
        return
    try:
        china_sheet.batch_update(updates)
    except Exception as e:
        logging.warning(f"CN –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ç–∞–±–ª–∏—Ü—ã: {e}")
        await message.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Ç–∞–±–ª–∏—Ü—ã!")
        return
    with open("pending_china.json", "w") as f:
        json.dump(notif, f)
    await message.answer(f"‚úÖ –ö–∏—Ç–∞–π: –Ω–∞–π–¥–µ–Ω–æ {len(notif)} —á–µ–ª–æ–≤–µ–∫. –†–∞—Å—Å—ã–ª–∫–∞ –Ω–∞—á–∞–ª–∞—Å—å...")
    asyncio.create_task(send_china_notifications())

# ‚úÖ –û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –ø–æ –í–´–î–ê–ù–ù–´–ú
async def send_issued_notifications():
    filename = "pending_issued.json"
    if not os.path.exists(filename): return
    with open(filename, "r") as f: notifications = json.load(f)
    count = 0
    for item in notifications:
        text = get_text("issued_notification", track=item["track"])
        try:
            await bot.send_message(item["user_id"], text)
            await asyncio.sleep(0.6)
        except Exception as e:
            logging.warning(f"ISS ‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ {item['user_id']}: {e}")
            continue
        try:
            issued_sheet.update(f"D{item['row_index']}", [[item['manager_code']]])
            await asyncio.sleep(0.2)
            issued_sheet.update(f"E{item['row_index']}", [[item['signature']]])
            await asyncio.sleep(0.2)
            issued_sheet.update(f"F{item['row_index']}", [[item['user_id']]])
            await asyncio.sleep(0.2)
            issued_sheet.update(f"B{item['row_index']}", [["‚úÖ"]])
            await asyncio.sleep(0.2)
        except Exception as e:
            logging.warning(f"ISS ‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Ç–∞–±–ª–∏—Ü—ã: {e}")
        count += 1
    os.remove(filename)
    for admin_id in ADMIN_IDS:
        await bot.send_message(admin_id, f"‚úÖ ISSUED: –û–ø–æ–≤–µ—â–µ–Ω–æ {count} —á–µ–ª–æ–≤–µ–∫.")

@router.message(Command("check_issued"))
async def check_issued_handler(message: Message):
    if str(message.from_user.id) not in ADMIN_IDS:
        await message.answer("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã!")
        return
    if os.path.exists("pending_issued.json"):
        await message.answer("‚ö†Ô∏è –ü—Ä–µ–¥—ã–¥—É—â–∞—è —Ä–∞—Å—Å—ã–ª–∫–∞ –µ—â—ë –Ω–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!")
        return
    records = issued_sheet.get_all_values()
    tracking = tracking_sheet.get_all_values()
    notif, updates, cache = [], [], set()
    for i in range(len(records) - 1, 0, -1):
        row = records[i]; track = row[0].strip().lower()
        if not track or (len(row) > 1 and row[1] in ["‚úÖ", "üü®"]): continue
        user_id = manager_code = signature = None
        for t in tracking[1:]:
            if track == t[0].strip().lower():
                user_id, manager_code, signature = t[4], t[2], t[3]; break
        if user_id:
            key = f"{user_id}:{track}"
            if key in cache: continue
            cache.add(key)
            notif.append({"row_index": i+1, "track": track.upper(), "user_id": user_id,
                          "manager_code": manager_code, "signature": signature})
            updates.append({"range": f"B{i+1}", "values": [["‚úÖ"]]})
    if not notif:
        await message.answer("üì≠ –ù–æ–≤—ã—Ö —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –≤ '–í—ã–¥–∞–Ω–Ω–æ–µ' –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")
        return
    try:
        issued_sheet.batch_update(updates)
    except Exception as e:
        logging.warning(f"ISS –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ç–∞–±–ª–∏—Ü—ã: {e}")
        await message.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Ç–∞–±–ª–∏—Ü—ã!")
        return
    with open("pending_issued.json", "w") as f: json.dump(notif, f)
    await message.answer(f"‚úÖ –í—ã–¥–∞–Ω–Ω–æ–µ: –Ω–∞–π–¥–µ–Ω–æ {len(notif)} —á–µ–ª–æ–≤–µ–∫. –†–∞—Å—Å—ã–ª–∫–∞ –Ω–∞—á–∞–ª–∞—Å—å...")
    asyncio.create_task(send_issued_notifications())

    
# ‚úÖ –û—Ç–º–µ–Ω–∞
@router.message(F.text.lower().in_(["–æ—Ç–º–µ–Ω–∞", "/cancel", "/–æ—Ç–º–µ–Ω–∞"]))
async def cancel_handler(message: Message, state: FSMContext):
    user_id = str(message.from_user.id)
    await state.clear()

    # –ë–µ–∑–æ–ø–∞—Å–Ω–æ —É–¥–∞–ª—è–µ–º –∞–∫—Ç–∏–≤–Ω—ã–π —Å—Ç–∞—Ç—É—Å, –µ—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è
    if "active_states" in globals():
        active_states.pop(user_id, None)

    await message.answer("‚ùå –î–µ–π—Å—Ç–≤–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=user_keyboard)




# ==========================
# üîπ –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
# ==========================
# ‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ç—Ä–µ–∫–∞ –≤ –±–∞–∑—É (–æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π –∫–æ–¥)
@router.message(lambda message: not message.text.startswith("/") and message.text not in [
    "üì¶ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç–∞—Ç—É—Å –ø–æ—Å—ã–ª–æ–∫", "üñä –ü–æ–¥–ø–∏—Å–∞—Ç—å —Ç—Ä–µ–∫-–Ω–æ–º–µ—Ä", "‚ùå –£–¥–∞–ª–∏—Ç—å —Ç—Ä–µ–∫-–Ω–æ–º–µ—Ä", "üìû –°–≤—è–∑–∞—Ç—å—Å—è —Å –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º",
    "/sign_track", "/delete_track", "/contact_manager"
])
async def add_tracking_handler(message: Message, state: FSMContext):
    # üîí –ü—Ä–æ–≤–µ—Ä–∫–∞: –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ ‚Äî –Ω–µ –¥–∞—ë–º –¥–æ–±–∞–≤–∏—Ç—å —Ç—Ä–µ–∫
    current_state = await state.get_state()
    if current_state in [
        Registration.name.state,
        Registration.city.state,
        Registration.phone.state,
        Registration.manager_code.state
    ]:
        await message.answer("‚ö†Ô∏è –í—ã –ø—Ä–æ—Ö–æ–¥–∏—Ç–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–≤–µ—Ä—à–∏—Ç–µ –µ—ë –∏–ª–∏ –≤–≤–µ–¥–∏—Ç–µ /–æ—Ç–º–µ–Ω–∞.")
        return
    
    if current_state == TrackManagement.deleting_track.state:
        await message.answer("‚ö†Ô∏è –°–µ–π—á–∞—Å –≤—ã —É–¥–∞–ª—è–µ—Ç–µ —Ç—Ä–µ–∫-–Ω–æ–º–µ—Ä. –ó–∞–≤–µ—Ä—à–∏—Ç–µ —ç—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –∏–ª–∏ –≤–≤–µ–¥–∏—Ç–µ /–æ—Ç–º–µ–Ω–∞.")
        return
    
    if current_state == TrackManagement.selecting_track.state:
        await message.answer("‚ö†Ô∏è –°–µ–π—á–∞—Å –≤—ã –ø–æ–¥–ø–∏—Å—ã–≤–∞–µ—Ç–µ —Ç—Ä–µ–∫-–Ω–æ–º–µ—Ä. –°–Ω–∞—á–∞–ª–∞ –∑–∞–≤–µ—Ä—à–∏—Ç–µ —ç—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –∏–ª–∏ –≤–≤–µ–¥–∏—Ç–µ /–æ—Ç–º–µ–Ω–∞.")
        return

        
    user_input = " ".join(message.text.split())  # –£–±–∏—Ä–∞–µ–º –ª–∏—à–Ω–∏–µ –ø—Ä–æ–±–µ–ª—ã
    user_id = str(message.from_user.id)

    logging.info(f"üì¶ –ü–æ–ª—É—á–µ–Ω –≤–≤–æ–¥: {user_input} –æ—Ç {user_id}")

    if not user_input:
        await message.answer("‚ùå –í—ã –Ω–µ –≤–≤–µ–ª–∏ —Ç—Ä–µ–∫-–Ω–æ–º–µ—Ä. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.")
        return

    # –†–∞–∑–¥–µ–ª—è–µ–º –≤–≤–æ–¥: –ø–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç ‚Äî —Ç—Ä–µ–∫, –æ—Å—Ç–∞–ª—å–Ω–æ–µ ‚Äî –ø–æ–¥–ø–∏—Å—å
    parts = user_input.split(" ", 1)
    track_number = parts[0].upper()  # –ü–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç ‚Äî —Ç—Ä–µ–∫-–Ω–æ–º–µ—Ä
    signature = parts[1] if len(parts) > 1 else ""  # –û—Å—Ç–∞–ª—å–Ω–æ–µ ‚Äî –ø–æ–¥–ø–∏—Å—å (–µ—Å–ª–∏ –µ—Å—Ç—å)

        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª–∏–Ω—ã —Ç—Ä–µ–∫-–Ω–æ–º–µ—Ä–∞
    if not (8 <= len(track_number) <= 20):
        await message.answer("‚ùå –¢—Ä–µ–∫-–Ω–æ–º–µ—Ä –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å –æ—Ç 8 –¥–æ 20 —Å–∏–º–≤–æ–ª–æ–≤. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.")
        return

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
    id_column = users_sheet.col_values(1)
    if user_id not in id_column:
        await message.answer("‚ö†Ô∏è –í—ã –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã! –ü—Ä–æ–π–¥–∏—Ç–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é –∫–æ–º–∞–Ω–¥–æ–π /register")
        return

    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–æ–≤—Ç–æ—Ä–Ω—ã–π —Ç—Ä–µ–∫
    existing_tracks = [
        row[0].strip().upper()
        for row in tracking_sheet.get_all_values()
        if len(row) > 4 and row[4] == user_id
    ]
    if track_number in existing_tracks:
        await message.answer(f"‚ö†Ô∏è –¢—Ä–µ–∫-–Ω–æ–º–µ—Ä {track_number} —É–∂–µ –¥–æ–±–∞–≤–ª–µ–Ω —Ä–∞–Ω–µ–µ.")
        return

    # –ü–æ–ª—É—á–∞–µ–º –∫–æ–¥ –º–µ–Ω–µ–¥–∂–µ—Ä–∞
    row_index = id_column.index(user_id) + 1
    manager_code = users_sheet.cell(row_index, 5).value
    current_date = datetime.now().strftime("%Y-%m-%d")

    logging.info(f"‚úÖ –î–æ–±–∞–≤–ª—è—é —Ç—Ä–µ–∫ –≤ Tracking: {track_number}, –ü–æ–¥–ø–∏—Å—å: {signature}")

    # –î–æ–±–∞–≤–ª—è–µ–º –≤ "–¢—Ä–µ–∫–∏–Ω–≥"
    tracking_sheet.append_row(
        [track_number, current_date, manager_code, signature, user_id],
        value_input_option="USER_ENTERED"
    )

    await message.answer(f"‚úÖ –¢—Ä–µ–∫-–Ω–æ–º–µ—Ä {track_number} —Å–æ—Ö—Ä–∞–Ω—ë–Ω{' —Å –ø–æ–¥–ø–∏—Å—å—é: ' + signature if signature else ''}.")



# ‚úÖ /update_texts ‚Äì –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–æ–≤ –∏–∑ Google Sheets (—Ç–æ–ª—å–∫–æ –¥–ª—è –∞–¥–º–∏–Ω–∞)
@router.message(F.text == "/update_texts")
async def update_texts_handler(message: Message):
    if str(message.from_user.id) not in ADMIN_IDS:
        await message.answer("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã!")
        return

    load_texts()  # –ó–∞–≥—Ä—É–∂–∞–µ–º —Ç–µ–∫—Å—Ç—ã –∑–∞–Ω–æ–≤–æ –∏–∑ Google Sheets
    await message.answer("‚úÖ –¢–µ–∫—Å—Ç—ã –æ–±–Ω–æ–≤–ª–µ–Ω—ã!")
    


async def main():
    load_texts()
    await set_bot_commands()
    await bot.delete_webhook(drop_pending_updates=True)
    logging.info("‚úÖ –ë–æ—Ç —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω –∏ –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ!")
    await dp.start_polling(bot)

if __name__ == "__main__":
    import asyncio
    asyncio.run(main())

